{"ast":null,"code":"var _toConsumableArray = require(\"/Users/benjamin/School/NewsApp/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"/Users/benjamin/School/NewsApp/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/benjamin/School/NewsApp/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar localList = require('./lang.json').words;\n\nvar baseList = require('badwords-list').array;\n\nvar Filter = /*#__PURE__*/function () {\n  \"use strict\";\n\n  /**\n   * Filter constructor.\n   * @constructor\n   * @param {object} options - Filter instance options\n   * @param {boolean} options.emptyList - Instantiate filter with no blacklist\n   * @param {array} options.list - Instantiate filter with custom list\n   * @param {string} options.placeHolder - Character used to replace profane words.\n   * @param {string} options.regex - Regular expression used to sanitize words before comparing them to blacklist.\n   * @param {string} options.replaceRegex - Regular expression used to replace profane words with placeHolder.\n   */\n  function Filter() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Filter);\n\n    Object.assign(this, {\n      list: options.emptyList && [] || Array.prototype.concat.apply(localList, [baseList, options.list || []]),\n      exclude: options.exclude || [],\n      placeHolder: options.placeHolder || '*',\n      regex: options.regex || /[^a-zA-Z0-9|\\$|\\@]|\\^/g,\n      replaceRegex: options.replaceRegex || /\\w/g\n    });\n  }\n  /**\n   * Determine if a string contains profane language.\n   * @param {string} string - String to evaluate for profanity.\n   */\n\n\n  _createClass(Filter, [{\n    key: \"isProfane\",\n    value: function isProfane(string) {\n      var _this = this;\n\n      return this.list.filter(function (word) {\n        var wordExp = new RegExp(\"\\\\b\".concat(word.replace(/(\\W)/g, '\\\\$1'), \"\\\\b\"), 'gi');\n        return !_this.exclude.includes(word.toLowerCase()) && wordExp.test(string);\n      }).length > 0 || false;\n    }\n    /**\n     * Replace a word with placeHolder characters;\n     * @param {string} string - String to replace.\n     */\n\n  }, {\n    key: \"replaceWord\",\n    value: function replaceWord(string) {\n      return string.replace(this.regex, '').replace(this.replaceRegex, this.placeHolder);\n    }\n    /**\n     * Evaluate a string for profanity and return an edited version.\n     * @param {string} string - Sentence to filter.\n     */\n\n  }, {\n    key: \"clean\",\n    value: function clean(string) {\n      var _this2 = this;\n\n      return string.split(/\\b/).map(function (word) {\n        return _this2.isProfane(word) ? _this2.replaceWord(word) : word;\n      }).join('');\n    }\n    /**\n     * Add word(s) to blacklist filter / remove words from whitelist filter\n     * @param {...string} word - Word(s) to add to blacklist\n     */\n\n  }, {\n    key: \"addWords\",\n    value: function addWords() {\n      var _this$list,\n          _this3 = this;\n\n      var words = Array.from(arguments);\n\n      (_this$list = this.list).push.apply(_this$list, _toConsumableArray(words));\n\n      words.map(function (word) {\n        return word.toLowerCase();\n      }).forEach(function (word) {\n        if (_this3.exclude.includes(word)) {\n          _this3.exclude.splice(_this3.exclude.indexOf(word), 1);\n        }\n      });\n    }\n    /**\n     * Add words to whitelist filter\n     * @param {...string} word - Word(s) to add to whitelist.\n     */\n\n  }, {\n    key: \"removeWords\",\n    value: function removeWords() {\n      var _this$exclude;\n\n      (_this$exclude = this.exclude).push.apply(_this$exclude, _toConsumableArray(Array.from(arguments).map(function (word) {\n        return word.toLowerCase();\n      })));\n    }\n  }]);\n\n  return Filter;\n}();\n\nmodule.exports = Filter;","map":{"version":3,"sources":["/Users/benjamin/School/NewsApp/frontend/node_modules/bad-words/lib/badwords.js"],"names":["localList","require","words","baseList","array","Filter","options","Object","assign","list","emptyList","Array","prototype","concat","apply","exclude","placeHolder","regex","replaceRegex","string","filter","word","wordExp","RegExp","replace","includes","toLowerCase","test","length","split","map","isProfane","replaceWord","join","from","arguments","push","forEach","splice","indexOf","module","exports"],"mappings":"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","sourcesContent":["const localList = require('./lang.json').words;\nconst baseList = require('badwords-list').array;\n\nclass Filter {\n\n  /**\n   * Filter constructor.\n   * @constructor\n   * @param {object} options - Filter instance options\n   * @param {boolean} options.emptyList - Instantiate filter with no blacklist\n   * @param {array} options.list - Instantiate filter with custom list\n   * @param {string} options.placeHolder - Character used to replace profane words.\n   * @param {string} options.regex - Regular expression used to sanitize words before comparing them to blacklist.\n   * @param {string} options.replaceRegex - Regular expression used to replace profane words with placeHolder.\n   */\n  constructor(options = {}) {\n    Object.assign(this, {\n      list: options.emptyList && [] || Array.prototype.concat.apply(localList, [baseList, options.list || []]),\n      exclude: options.exclude || [],\n      placeHolder: options.placeHolder || '*',\n      regex: options.regex || /[^a-zA-Z0-9|\\$|\\@]|\\^/g,\n      replaceRegex: options.replaceRegex || /\\w/g\n    })\n  }\n\n  /**\n   * Determine if a string contains profane language.\n   * @param {string} string - String to evaluate for profanity.\n   */\n  isProfane(string) {\n    return this.list\n      .filter((word) => {\n        const wordExp = new RegExp(`\\\\b${word.replace(/(\\W)/g, '\\\\$1')}\\\\b`, 'gi');\n        return !this.exclude.includes(word.toLowerCase()) && wordExp.test(string);\n      })\n      .length > 0 || false;\n  }\n\n  /**\n   * Replace a word with placeHolder characters;\n   * @param {string} string - String to replace.\n   */\n  replaceWord(string) {\n    return string\n      .replace(this.regex, '')\n      .replace(this.replaceRegex, this.placeHolder);\n  }\n\n  /**\n   * Evaluate a string for profanity and return an edited version.\n   * @param {string} string - Sentence to filter.\n   */\n  clean(string) {\n    return string.split(/\\b/).map((word) => {\n      return this.isProfane(word) ? this.replaceWord(word) : word;\n    }).join('');\n  }\n\n  /**\n   * Add word(s) to blacklist filter / remove words from whitelist filter\n   * @param {...string} word - Word(s) to add to blacklist\n   */\n  addWords() {\n    let words = Array.from(arguments);\n\n    this.list.push(...words);\n\n    words\n      .map(word => word.toLowerCase())\n      .forEach((word) => {\n        if (this.exclude.includes(word)) {\n          this.exclude.splice(this.exclude.indexOf(word), 1);\n        }\n      });\n  }\n\n  /**\n   * Add words to whitelist filter\n   * @param {...string} word - Word(s) to add to whitelist.\n   */\n  removeWords() {\n    this.exclude.push(...Array.from(arguments).map(word => word.toLowerCase()));\n  }\n}\n\nmodule.exports = Filter;"]},"metadata":{},"sourceType":"script"}